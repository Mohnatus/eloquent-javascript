# Обработка событий

## События от кнопок клавиатуры

События ```keydown``` и ```keyup``` дают информацию о физическом нажатии кнопок. А если вам нужно узнать, какой текст вводит пользователь? Создавать его из нажатий кнопок – неудобно. Для этого существует событие ```keypress```, происходящее сразу после ```keydown``` (и повторяющееся вместе с ```keydown```, если клавишу продолжают удерживать), но только для тех кнопок, которые выдают символы. Свойство объекта события charCode содержит код, который можно интерпретировать как код Unicode. Мы можем использовать функцию ```String.fromCharCode``` для превращения кода в строку из одного символа.

```js
addEventListener("keypress", function(event) {
    console.log(String.fromCharCode(event.charCode));
});
```

## Движение мыши

К сожалению, создание такого эффекта не ограничивается запуском его при событии «mouseover» и завершением при событии «mouseout». При движении мыши от узла к его дочерним узлам на родительском узле происходит событие «mouseout», хотя мышь, вообще говоря, его и не покидала. Что ещё хуже, эти события распространяются как и все другие, поэтому вы всё равно получаете «mouseout» при уходе курсора с одного их дочерних узлов того узла, где вы зарегистрировали обработчик.

Для обхода проблемы можно использовать свойство ```relatedTarget``` объекта событий. Он сообщает, на каком узле была до этого мышь при возникновении события «mouseover», и на какой элемент она переходит при событии «mouseout». Нам надо менять эффект, только когда ```relatedTarget``` находится вне нашего целевого узла. Только в этом случае событие на самом деле представляет собой переход на наш узел (или уход с узла).

[```mousemove.js```](./mousemove.js)

## События прокрутки 

[```scroll-progress.js```](./scroll-progress.js)

В примере в правом верхнем углу документа создаётся индикатор процесса, который заполняется по мере прокрутки элемента вниз.

## Событие загрузки

Когда заканчивается загрузка страницы, на объектах ```window``` и ```body``` запускается событие ```load```. Это часто используется для планирования инициализирующих действий, которым необходим полностью построенный документ. 

У элементов типа картинок или тегов скрипта, которые загружают внешний файл, тоже есть событие ```load```, которое показывает, что файл загружен. Как и события фокуса, события загрузки не распространяются.

Когда страница закрывается или с неё уходят (например, по ссылке), запускается событие ```beforeunload```. Основная цель – защитить пользователя от случайной потери данных при закрытии документа. Предотвращение закрытия страницы не производится, как вы могли подумать, при помощи ```preventDefault```. Вместо этого используется возврат строки из обработчика. Строка будет использована в диалоге, который спрашивает пользователя, хочет ли он остаться на странице или покинуть её. Этот механизм гарантирует, что пользователь может покинуть страницу, даже если на ней работает зловредный скрипт, который бы хотел не отпускать пользователя, а вместо этого показывал бы ему мошенническую рекламу по снижению веса.

## Устранение помех (debouncing)

У некоторых событий есть возможность выполняться быстро и много раз подряд (например, ```mousemove``` и ```scroll```). При обработке таких событий надо быть осторожным и не делать ничего «тяжёлого», или ваш обработчик займёт столько времени на выполнение, что взаимодействие с документом будет медленным и прерывистым.

Если в таком обработчике надо сделать что-то нетривиальное, можно использовать ```setTimeout```, чтобы гарантировать, что вы делаете это не слишком часто. Это обычно называют «устранением помех» в событии. К этому существует несколько слегка различающихся подходов.

В первом примере надо сделать что-то, когда пользователь печатает, но не надо делать это сразу после запуска каждого события нажатия на клавиши. Когда они быстро печатают, нам надо подождать, когда возникнет пауза. Вместо немедленного выполнения действия в обработчике, мы устанавливаем таймаут. Также мы очищаем предыдущий таймаут, если он был, так что если события близко одно от другого (ближе, чем задержка таймера), предыдущее событие будет отменено.

```js
var textarea = document.querySelector("textarea");
var timeout;
textarea.addEventListener("keydown", function() {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
        console.log("Вы остановились.");
    }, 500);
});
```

Если задать ```undefined``` для ```clearTimeout```, или вызвать его с таймаутом, который уже произошёл, то ничего не произойдёт. Таким образом, не надо осторожничать при его вызове, и мы просто поступаем так для каждого события.

Можно использовать немного другой подход, если нам надо разделить ответы минимальными промежутками времени, но при этом запускать их в то время, когда происходят события, а не после. К примеру, надо реагировать на события ```mousemove```, показывая текущие координаты мыши, но только каждые 250 миллисекунд.

```js
function displayCoords(event) {
    document.body.textContent =
        "Мышь на " + event.pageX + ", " + event.pageY;
}

var scheduled = false, lastEvent;
addEventListener("mousemove", function(event) {
    lastEvent = event;
    if (!scheduled) {
        scheduled = true;
        setTimeout(function() {
        scheduled = false;
        displayCoords(lastEvent);
        }, 250);
    }
});
```

## Упражнения

### [Цензура клавиатуры](./censorship.html)

В промежутке с 1928 по 2013 год турецкие законы запрещали использование букв Q, W и X в официальных документах. Это являлось частью общей инициативы подавления курдской культуры – эти буквы используются в языке курдов, но не у турков.

В качестве упражнения на тему странного использования технологий, я прошу вас запрограммировать поле для ввода текста так, чтобы эти буквы нельзя было туда вписать. Насчет копирования и вставки и других подобных возможных обходов правила не беспокойтесь.

### [След мыши](./trail.html)

В ранние дни JavaScript, когда было время кричащих домашних страниц с обилием анимированных картинок, люди использовали язык очень вдохновляющими способами. Одним из них был «след мыши» — серия картинок, которые следовали за курсором при его движении по странице.

Я хочу, что бы вы в упражнении сделали такой след. Используйте с абсолютным позиционированием, фиксированным размером и цветом фона. Создайте кучку элементов и при движении мыши показывайте их следом за курсором.

### [Закладки](./tabs.html)

В упражнении вам нужно сделать простой интерфейс закладок. Напишите функцию ```asTabs```, которая принимает узел DOM, и создаёт закладочный интерфейс, показывая дочерние элементы этого узла. Ей нужно вставлять список элементов ```button``` вверху узла, по одному на каждый дочерний элемент, содержащих текст, полученный из атрибута ```data-tabname```. Все, кроме одного из дочерних элементов, должны быть спрятаны (при помощи ```display: none```), а текущий видимый узел можно выбирать нажатием кнопки.

Когда оно заработает, расширьте функционал, чтобы у текущей активной кнопки был свой стиль.
